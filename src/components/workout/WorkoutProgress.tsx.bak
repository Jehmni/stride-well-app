import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { CheckCircle, Award, RefreshCw, Clock } from "lucide-react";
import { WorkoutExerciseDetail } from "./types";
import ExerciseTracker from "./ExerciseTracker";
import { supabase } from "@/integrations/supabase/client";
import { logExerciseCompletionRPC } from "@/integrations/supabase/functions";
import { toast } from "@/components/ui/use-toast";
import { CheckCircle, Award, CloudSync } from "lucide-react";
import { WorkoutExerciseDetail } from "./types";
import ExerciseTracker from "./ExerciseTracker";
import { supabase } from "@/integrations/supabase/client";
import { logExerciseCompletionRPC } from "@/integrations/supabase/functions";
import { toast } from "@/components/ui/use-toast";

interface WorkoutProgressProps {
  exercises: WorkoutExerciseDetail[];
  workoutId: string;
  userId: string | undefined;
  onWorkoutCompleted: () => void;
}

const WorkoutProgress: React.FC<WorkoutProgressProps> = ({ 
  exercises, 
  workoutId,
  userId,
  onWorkoutCompleted
}) => {
  const [completedExercises, setCompletedExercises] = useState<string[]>([]);
  const [progress, setProgress] = useState<number>(0);
  const [isWorkoutComplete, setIsWorkoutComplete] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [isSyncing, setIsSyncing] = useState<boolean>(false);
  const [lastSynced, setLastSynced] = useState<Date | null>(null);

  // Load local progress and sync with remote progress on component mount
  useEffect(() => {
    if (!exercises.length || !userId) return;
    
    // First, load from localStorage for immediate display
    loadLocalProgress();
    
    // Then attempt to load from Supabase to ensure cross-device consistency
    loadRemoteProgress();
  }, [exercises, workoutId, userId]);

  // Load progress stored locally
  const loadLocalProgress = () => {
    const savedCompleted = JSON.parse(localStorage.getItem(`completedExercises-${workoutId}`) || '{}');
    const completedIds = exercises
      .filter(ex => savedCompleted[ex.id])
      .map(ex => ex.id);
    
    setCompletedExercises(completedIds);
    updateProgressState(completedIds);
  };

  // Load progress from Supabase database
  const loadRemoteProgress = async () => {
    if (!userId) return;
    
    try {
      setIsSyncing(true);
      
      // First check if we have a temporary workout progress record for this user/workout
      const { data: progressData, error } = await supabase
        .from('workout_progress')
        .select('completed_exercises, last_updated')
        .eq('user_id', userId)
        .eq('workout_id', workoutId)
        .maybeSingle();
      
      if (error) {
        console.error("Error loading remote progress:", error);
        return;
      }
      
      if (progressData) {
        // We have remote progress, compare with local progress
        const remoteCompleted = progressData.completed_exercises as string[];
        const localSaved = JSON.parse(localStorage.getItem(`completedExercises-${workoutId}`) || '{}');
        
        // Merge remote and local data, keeping the most complete version
        const localCompleted = Object.keys(localSaved).filter(id => localSaved[id]);
        
        // Use whichever list has more completed exercises
        if (remoteCompleted.length > localCompleted.length) {
          console.log("Remote progress ahead of local, updating local");
          
          // Update local storage with remote data
          const updatedLocalSaved = {};
          remoteCompleted.forEach(id => { updatedLocalSaved[id] = true; });
          localStorage.setItem(`completedExercises-${workoutId}`, JSON.stringify(updatedLocalSaved));
          
          // Update state
          setCompletedExercises(remoteCompleted);
          updateProgressState(remoteCompleted);
          setLastSynced(new Date(progressData.last_updated));
        } else if (localCompleted.length > remoteCompleted.length) {
          // Local ahead of remote, sync local to remote
          console.log("Local progress ahead of remote, syncing to remote");
          await syncToRemote(localCompleted);
        } else {
          // They're the same or local is empty, just set the last synced time
          setLastSynced(new Date(progressData.last_updated));
        }
      } else if (completedExercises.length > 0) {
        // No remote data but we have local data, sync local to remote
        syncToRemote(completedExercises);
      }
    } catch (error) {
      console.error("Error in remote progress sync:", error);
    } finally {
      setIsSyncing(false);
    }
  };
  
  // Update progress calculation
  const updateProgressState = (completedIds: string[]) => {
    const newProgress = exercises.length 
      ? Math.round((completedIds.length / exercises.length) * 100) 
      : 0;
    
    setProgress(newProgress);
    setIsWorkoutComplete(newProgress === 100);
  };
  
  // Sync local completed exercises to Supabase
  const syncToRemote = async (completedIds: string[]) => {
    if (!userId) return;
    
    try {
      setIsSyncing(true);
      
      const now = new Date().toISOString();
      
      // Upsert the progress data
      const { error } = await supabase
        .from('workout_progress')
        .upsert({
          user_id: userId,
          workout_id: workoutId,
          completed_exercises: completedIds,
          last_updated: now
        }, {
          onConflict: 'user_id,workout_id'
        });
        
      if (error) {
        console.error("Error syncing to remote:", error);
        return;
      }
      
      setLastSynced(new Date(now));
    } catch (error) {
      console.error("Error in syncToRemote:", error);
    } finally {
      setIsSyncing(false);
    }
  };
  
  const handleExerciseComplete = (exerciseId: string) => {
    if (!completedExercises.includes(exerciseId)) {
      const updated = [...completedExercises, exerciseId];
      setCompletedExercises(updated);
      
      // Save to localStorage
      const savedCompleted = JSON.parse(localStorage.getItem(`completedExercises-${workoutId}`) || '{}');
      savedCompleted[exerciseId] = true;
      localStorage.setItem(`completedExercises-${workoutId}`, JSON.stringify(savedCompleted));
      
      // Update progress state
      updateProgressState(updated);
      
      // Queue sync to remote database
      if (userId) {
        syncToRemote(updated);
      }
      
      // Check if workout is complete
      if (updated.length === exercises.length) {
        setIsWorkoutComplete(true);
        completeWorkout();
      }
    }
  };
  
  // Manually trigger a sync with remote database
  const handleManualSync = () => {
    if (userId && completedExercises.length > 0) {
      syncToRemote(completedExercises);
    }
  };

  const completeWorkout = async () => {
    if (!userId) {
      toast({
        title: "Error",
        description: "You must be logged in to save workout progress",
        variant: "destructive"
      });
      return;
    }
    
    try {
      setIsSaving(true);
      console.log("Starting workout completion process");
      
      // Calculate some basic stats based on completed exercises
      const totalDuration = Math.floor(
        exercises.reduce((total, ex) => {
          // Estimate time as sets * (rep time + rest time)
          const repTime = ex.duration || 30; // Default 30s if no duration specified
          return total + (ex.sets * (repTime + ex.rest_time));
        }, 0) / 60
      ); // Convert to minutes
      
      // Estimate calories burned (very rough formula based on duration and intensity)
      const caloriesBurned = Math.floor(totalDuration * 8 + Math.random() * 50);
      
      let actualWorkoutId = workoutId;
      
      // For "today-workout" or any non-UUID workoutId, create a real workout entry first
      if (workoutId === 'today-workout' || !isValidUUID(workoutId)) {
        console.log("Creating new workout record for temporary workout ID:", workoutId);
        
        // Create a new workout
        const { data: workoutData, error: workoutError } = await supabase
          .from('workouts')
          .insert({
            user_id: userId,
            name: "Daily Workout",
            description: "Completed daily workout",
            day_of_week: new Date().getDay() === 0 ? 7 : new Date().getDay() // Convert Sunday from 0 to 7
          })
          .select('id')
          .single();
          
        if (workoutError) {
          console.error("Error creating workout record:", workoutError);
          throw workoutError;
        }
        
        console.log("Created new workout with ID:", workoutData.id);
        actualWorkoutId = workoutData.id;
        
        // Now insert the exercises into workout_exercises table
        for (let i = 0; i < exercises.length; i++) {
          const ex = exercises[i];
          
          // Skip exercises with invalid exercise_id (e.g. "default-*" temporary IDs)
          if (ex.exercise_id && !ex.exercise_id.startsWith('default-')) {
            const { error: exerciseError } = await supabase
              .from('workout_exercises')
              .insert({
                workout_id: actualWorkoutId,
                exercise_id: ex.exercise_id,
                sets: ex.sets,
                reps: ex.reps,
                duration: ex.duration,
                rest_time: ex.rest_time,
                order_position: i,
                notes: ex.notes
              });
              
            if (exerciseError) {
              console.error("Error inserting workout exercise:", exerciseError);
              // Continue even if one fails
            }
          }
        }
      }
        // Insert into workout_logs table
      const { data: logData, error: logError } = await supabase
        .from('workout_logs')
        .insert({
          user_id: userId,
          workout_id: actualWorkoutId,
          completed_at: new Date().toISOString(),
          duration: totalDuration,
          calories_burned: caloriesBurned,
          workout_type: 'completed', // Explicitly mark as a completed workout
          is_custom: false // This is not a custom workout
        })
        .select('id');
        
      if (logError) {
        throw logError;
      }
      
      console.log("Workout log created:", logData);
      
      // Log each completed exercise
      if (logData && logData.length > 0) {
        const workoutLogId = logData[0].id;
        console.log("Created workout log with ID:", workoutLogId);
          // Log each exercise completion directly using the RPC function
        for (const ex of exercises) {
          try {
            // Skip if exercise_id looks like a temporary ID
            if (!ex.exercise_id || ex.exercise_id.startsWith('default-')) {
              console.log(`Skipping temporary exercise ID: ${ex.exercise_id}`);
              continue;
            }
            
            console.log(`Logging exercise completion: Exercise ID=${ex.exercise_id}, Sets=${ex.sets}, Workout Log ID=${workoutLogId}`);
            
            // Try RPC function first
            try {
              const { data, error } = await supabase.rpc('log_exercise_completion', {
                workout_log_id_param: workoutLogId,
                exercise_id_param: ex.exercise_id,
                sets_completed_param: ex.sets,
                reps_completed_param: ex.reps || null,
                weight_used_param: null,
                notes_param: null
              });
              
              if (error) {
                throw error;
              } else {
                console.log(`Successfully logged exercise ${ex.exercise_id}:`, data);
                continue;
              }
            } catch (rpcError) {
              console.warn(`RPC error, falling back to direct insert for exercise ${ex.exercise_id}:`, rpcError);
            }
            
            // Fall back to direct insert if RPC fails
            const { data: directData, error: directError } = await supabase
              .from('exercise_logs')
              .insert({
                workout_log_id: workoutLogId,
                exercise_id: ex.exercise_id,
                sets_completed: ex.sets,
                reps_completed: ex.reps || null,
                weight_used: null,
                completed_at: new Date().toISOString()
              });
              
            if (directError) {
              console.error(`Direct insert error for exercise ${ex.exercise_id}:`, directError);
            } else {
              console.log(`Successfully logged exercise ${ex.exercise_id} via direct insert`);
            }
          } catch (err) {
            console.error(`Error in exercise logging for ${ex.exercise_id}:`, err);
            // Continue with next exercise even if one fails
          }
        }
      }
      
      toast({
        title: "Success",
        description: "Workout completed! Great job!",
      });
      
      onWorkoutCompleted();
    } catch (error: any) {
      console.error("Error saving completed workout:", error);
      toast({
        title: "Error",
        description: "Failed to save workout completion. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsSaving(false);
    }
  };  const resetWorkoutProgress = () => {
    try {
      console.log("Resetting workout progress for workout ID:", workoutId);
      
      // Clear completed exercises from localStorage
      localStorage.removeItem(`completedExercises-${workoutId}`);
      
      // Reset state
      setCompletedExercises([]);
      setProgress(0);
      setIsWorkoutComplete(false);
      
      // Log the reset for debugging
      console.log("Workout progress reset successfully");
      
      // Notify parent that we're starting a new session
      // This allows parent to refresh workout data if needed without refreshing entire page
      onWorkoutCompleted();
    } catch (error) {
      console.error("Error resetting workout progress:", error);
    }
  };

  // Helper function to validate UUID
  const isValidUUID = (uuid: string) => {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  };

  if (isWorkoutComplete) {
    return (
      <div className="bg-green-50 dark:bg-green-900/20 p-6 rounded-lg text-center">
        <div className="flex justify-center mb-4">
          <Award className="h-16 w-16 text-green-500" />
        </div>
        <h3 className="text-xl font-bold text-green-700 dark:text-green-400 mb-2">
          Workout Complete!
        </h3>
        <p className="text-gray-600 dark:text-gray-300 mb-6">
          Congratulations on completing today's workout! Your progress has been saved.
        </p>
        <Button 
          variant="outline"
          onClick={resetWorkoutProgress}
        >
          Start New Session
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div>
        <div className="flex justify-between mb-2">
          <span className="text-sm font-medium">Progress</span>
          <span className="text-sm font-medium">{progress}%</span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      <div className="space-y-2">
        <h3 className="text-lg font-medium flex items-center">
          <CheckCircle className="mr-2 h-5 w-5 text-gray-400" />
          Exercises to Complete
        </h3>
        
        {exercises.length > 0 ? (
          <div className="space-y-2">
            {exercises.map((exercise) => (
              <ExerciseTracker 
                key={exercise.id}
                exercise={exercise}
                onComplete={handleExerciseComplete}
              />
            ))}
          </div>
        ) : (
          <p className="text-gray-500">No exercises added to this workout yet.</p>
        )}
      </div

      <div className="flex items-center justify-between text-sm text-gray-500">
        <div className="flex items-center">
          <CloudSync className="mr-1.5 h-4 w-4 text-gray-400" />
          <span>
            {isSyncing 
              ? "Syncing progress..." 
              : lastSynced 
                ? `Last synced: ${lastSynced.toLocaleString()}` 
                : "Not synced yet"
            }
          </span>
        </div>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={handleManualSync}
          disabled={isSyncing}
        >
          {isSyncing ? "Syncing..." : "Sync Progress"}
        </Button>
      </div>
    </div>
  );
};

export default WorkoutProgress;
